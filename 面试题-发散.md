# 发散
##### 1. 说一个你曾经参与过的项目，在这过程中经历了哪些困难，最后如何克服？
1. 《环球网校》：关于断点续传这块。
	1. 当时用的是NSURLSessionDownloadTask来下载的，它里面有个cancelByProducingResumeData的方法，可以实现断点续传（resumeData：包含了下载地址，已下载自己数，原始的request的Data,临时文件的存储目录，E-Tag等信息），但是由于我们的下载地址是会改变的，所以这个resumeData，并不能正常使用。google后，发现有这种中做法，直接将data进行解码，然后修改后重新发起请求。
	2. 但是这种方法太过繁琐，这边后来找人借鉴了下经验。采用了这种办法：我们每次下载，暂停的时候，都将其已下载的文件保存到document中，并记录已下载的byte，然后下次下载的时候，修改http，Head里面的range，只下载指定部分的数据。
	3. 当所有的文件下载完毕后，我们对这些文件按顺序进行合并，然后就实现断点续传了。
2. 《题库》：界面嵌套过深，数据需要一层层的传入+传出，代理回调写哭了。。
	1. 后来，写了个单例，由单例来管理这些数据，所有进入做题页面，单例中的数据初始化，退出做题页面，将其清空。【1、节省代码 2.数据逻辑集中，方便调试】
	
##### 2. 你有没有干过什么事情最后却铩羽而归？
1. 《面试》：最大的可能就是年初的面试了，本意是考虑到之后的职业生涯发展，想找个稍微大点的公司，但是投过N多大公司，大多数都没有回音。只有阿里有个面试
	1. 没有回音的原因个人觉得可能有两方面：1.个人技术可能确实达不到要求（因为经常会看百度，阿里相关技术的博客+微博，觉得人确实是牛逼）2.学历太低，直接就被系统过滤掉了  3.确实没有什么大型，知名的项目经验
	2. 为什么技术没达标：1.基础确实有点差，没有学过计算机底层相关，算法也看得少的(平时这块确实看的也少，主要关注点在iOS开发这块) 2.虽然工作几年了，但是前几年几乎是在浪费时间，心思也不在开发生面  3.后来自学iOS后，才一步步开窍了。
	3. 阿里面试怎么样呢：阿里面的比较细，比如，runtime方法替换他们会具体问到是哪个方法，方法名是什么，当时准备的确实不充分，没答上来【objc_replaceMethod】
	4. 教训：之后开始看些iOS稍微底层的一些东西，也看了点算法什么的，也有计划，之后整体将计算机系统什么的看一遍
2. 如果还问，可就之前题库项目的人员变动来说。人员分工不平，导致员工心理不平衡。应该是分配给谁的事就得谁做。不能说因为他做不完，就找别的同事帮她做。

##### 3. 在某个休息天，突然有同事打电话来要你快速回复有关于你最近写的代码片段的问题，你会不会觉得生气烦躁？
1. 可能会抱怨两句，但是该做的事情还是做，毕竟是自己代码的坑

##### 4. 你被要求去搞定一堆艰巨的代码，但是你却不知道它是如何工作的，没有文档也没有测试，你会怎么做？
1. 先运行下程序，看实现什么功能，然后看需求，具体是让我弄哪一块的内容，根据关键字找到对应的代码，然后大略的看一遍，了解代码结构+实现
2. 如果具体要改的话，找到具体的代码段，稍微进行修改，再运行，确认是这块的，然后之后就可以正常运行了。。

##### 5. 在Zelda系列中你最喜欢什么游戏？你还喜欢哪些？你是否曾想过如果是你先开发的minecraft，那会怎么样？
1. 什么是zelda，没接触过

##### 6. 你喜欢什么网站？
1. GitBook：经常有人会写点文章+个人感悟，放在上面，没事看看挺不错的
2. GitHub，stockoverflow就不用说了
3. 利器：会看看专业人士都用什么app，有什么推荐的东西

##### 7. 你会推荐什么书作为必读？
1. 如果是iOS方面的话，推荐《programming ios 9》里面内容讲的相对比初学的深入，也系统。之前从虾神那边知道的这本书。
2. 《Objective-C高级编程 iOS与OS X多线程和内存管理》主要讲了内存管理+block+GCD，讲的比较底层，有利于理解block，RAC的实现细节
3. 《Effective Objective-C 2.0》:讲了一些代码规范，运行时，GCD，内存管理相关的东西，但这个比较早之前看的，有点忘了。。

##### 8. 最后一个但并非是最不重要的，请解释以下名词：DRY、SOLID、YAGNI、乐观锁与悲观锁）、MVC与MVVM(可自行添加)
1. `[DRY]`:don't repeat yourself，指的是避免重复代码，封装啊封装
2. `[SOLID]`:面向对象设计
	1. S：单一功能原则，认为对象应该仅具有一种单一功能的概念
	2. O：开闭原则，认为“软件体应该是对于扩展开放的，但是对于修改封闭”的概念
	3. L：里氏替换原则，认为“程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的”的概念
	4. I：接口隔离原则，认为“多个特定客户端接口要好于一个宽泛用途的接口”的感念
	5. D：依赖反转原则，认为一个方法应遵从“依赖于抽象而不是实例”的概念
![](http://7xwb99.com1.z0.glb.clouddn.com/2016-07-18-14688384301557.jpg)
3. `[YAGNI]`:You Aren't Gonna Need It
	1. 主要指的是不要把简单的事情复杂化，例如重构
	2. 不需要为目前不需要的功能添加代码
	3. 个人觉得，可以保留部分扩展，但是不要复杂化
4. `[乐观锁与悲观锁]`
	1. `[乐观锁]`：假设所有的并发操作不会有冲突，当一个事务运行完毕后，检查期间是否有其他失误对数据进行修改了，如果有修改，则回滚自己(或者给予相应的提示)，如果没有，则直接通过。
	2. `[悲观锁]`：假设所有的并发都会相互有冲突。在执行事务的时候，对相应的数据进行加锁。之后锁消失后，其他线程/事务，才能对其进行操作
5. `[MVC]`：
	1. Model：与业务相关的数据处理
	2. View：负责生成界面UI，并显示数据
	3. Controller：负责连接View+Model，处理事件相应
6. `[MVVM]`:
	1. Model:与业务相关的数据处理
	2. View:负责生成界面UI
	3. View-Model:界面数据逻辑，与界面绑定
	
	
	
	




